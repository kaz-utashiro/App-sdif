#!/usr/bin/perl -CSDA

require 5.010;
use strict;
use warnings;
use utf8;
use Carp;
use List::Util qw(min max);
use Getopt::Long;
use Pod::Usage;
use Text::ParseWords qw(shellwords);
use Text::Glob qw(match_glob);
use Term::ANSIColor qw(:constants);
use Data::Dumper;
$Data::Dumper::Terse = 1;

##
## sdif: sdiff clone
##
## Copyright (c) 1992-2014 Kazumasa Utashiro
##
## Original version on Jul 24 1991
;; my $rcsid = q$Id: sdif,v 2.2 2014/01/19 14:50:28 utashiro Exp $;
##
## Use and redistribution for ANY PURPOSE are granted as long as all
## copyright notices are retained.  Redistribution with modification
## is allowed provided that you make your modified version obviously
## distinguishable from the original one.  THIS SOFTWARE IS PROVIDED
## BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE
## DISCLAIMED.
##

=pod

=head1 NAME

sdif - sdiff clone

=head1 SYNOPSIS

sdif file_1 file_2

diff ... | sdif

    --number, -n	print line number
    --truncate, -t	truncate long line
    --onword		fold line on word boundaries
    --width, -w #	specify width of output (default is 80)
    --diff=s		set diff command
    --diffopts=s	set diff command options
    --cdif		use ``cdif'' as word context diff backend
    --cdifopts		set ``cdif'' command options
    --[no]color		use color or not
    --colormap, --cm	specify color map
    --mark=position	mark position (right, left, center, side) or no

=cut

my $opt_n;
my $opt_l;
my $opt_s;
my $opt_q;
my $opt_d;
my $opt_c;
my $opt_u;
my $opt_truncate;
my $opt_onword;
my $opt_cdif;
my @opt_cdifopts;
my $opt_env;
my @opt_colormap;
my @opt_diffopts;
my $diff;
my $screen_width;
my $column_width;

my $opt_color = 1;
my $opt_mark = "center";
my $opt_w;

##
## Special treatment --noenv option.
##
if (grep { $_ eq '--noenv' } @ARGV) {
    $opt_env = 0;
}
if ($ENV{'SDIFOPTS'}) {
    require('shellwords.pl');
    unshift(@ARGV, &shellwords($ENV{'SDIFOPTS'}));
}

my @optargs = (
    "n|number!" => \$opt_n,
    "truncate|t!" => \$opt_truncate,
    "onword|W!" => \$opt_onword,
    "mark=s" => \$opt_mark,
    "l" => \$opt_l,
    "s" => \$opt_s,
    "w=i" => \$opt_w,

    "d+" => \$opt_d,
    "h|help" => sub { usage() },
    "man" => sub { pod2usage({-verbose => 2}) },

    "env!" => \$opt_env,
    "diff=s" => \$diff,
    "diffopts=s" => \@opt_diffopts,
    "color!" => \$opt_color,
    "colormap|cm=s" => \@opt_colormap,
    "c|context" => sub { push(@opt_diffopts, "-c") },
    "u|unified" => sub { push(@opt_diffopts, "-u") },
    "C=i" => sub { push(@opt_diffopts, "-C" . ($_[1] > 0 ? $_[1] : '')) },
    "U=i" => sub { push(@opt_diffopts, "-U" . ($_[1] > 0 ? $_[1] : '')) },
    "cdif" => \$opt_cdif,
    "cdifopts=s" => \@opt_cdifopts,

    "--mecab" => sub { push @opt_cdifopts, "--mecab" },
);

my @SAVEDARGV = @ARGV;
Getopt::Long::Configure("bundling");
GetOptions(@optargs) || usage();

warn "\@ARGV = (@SAVEDARGV)\n" if $opt_d;

my %colormap = (
    OCOMMAND => "CSE",
    NCOMMAND => "MSE",
    OFILE => "CDE",
    NFILE => "MDE",
    OMARK => "wC",
    NMARK => "wM",
    UMARK => "w",
    OLINE => "Y",
    NLINE => "Y",
    ULINE => "Y",
    OTEXT => "C",
    NTEXT => "M",
    UTEXT => "",
    );

my $colorize;
if ($opt_color) {
    if (@opt_colormap) {
	map {
	    my $c = pop @$_;
	    map { $colormap{$_} = $c }
	    map { match_glob $_, keys %colormap }
	    @$_;	
	}	
	map { [ split /=/, $_, -1 ] }
	map { split /,/ }
	@opt_colormap;
    }
    $colorize = \&color;
} else {
    $colorize = sub { $_[1] } ;
}

$diff ||= 'diff';

my($OLD, $NEW, $DIFF);
if (@ARGV == 2) {
    ($OLD, $NEW) = @ARGV;
    $DIFF = "$diff @opt_diffopts $OLD $NEW |";
} elsif (@ARGV < 2) {
    $DIFF = shift || '-';
    $opt_s++;
} else {
    usage("Unexpected arguments.\n\n");
}
my $readfile = ($OLD and $NEW) && !($opt_s || $opt_c || $opt_u);

sub usage {
    select STDERR;
    print @_;
    pod2usage(-verbose => 0, -exitval => "NOEXIT");
    print "$rcsid\n" if $rcsid =~ /:/;
    exit;
}

use constant {
    RIGHT => 'right',
    LEFT => 'left',
    NO => 'no',
};
my %markpos = (
    center => [ RIGHT, LEFT  ],
    side   => [ LEFT,  RIGHT ],
    right  => [ RIGHT, RIGHT ],
    left   => [ LEFT,  LEFT  ],
    no     => [ NO,    NO    ],
    );
my($omarkpos, $nmarkpos);
if (my $pos = $markpos{$opt_mark}) {
    ($omarkpos, $nmarkpos) = @$pos;
} else {
    my @keys = sort keys %markpos;
    usage "Use one from (@keys) for option --mark\n\n"
}

$screen_width = $opt_w || &terminal_width;
$column_width = max(1, int(($screen_width - ($opt_mark ne NO ? 2 : 0)) / 2));

if ($opt_d) {
    printf STDERR "\$OLD = %s\n", $OLD // "undef";
    printf STDERR "\$NEW = %s\n", $NEW // "undef";
    printf STDERR "\$DIFF = %s\n", $DIFF // "undef";
}

if ($readfile) {
    open(OLD, $OLD) || die "$OLD: $!\n";
    open(NEW, $NEW) || die "$NEW: $!\n";
}

if ($opt_cdif) {
    my $pid = open DIFF, '-|';
    if (not defined $pid) {
	die "$!" if not defined $pid;
    }
    ## child
    elsif ($pid == 0) {
	if ($DIFF ne '-') {
	    open(STDIN, $DIFF) || die "cannot open diff: $!\n";
	}
	do { exec join ' ', qw(cdif --nocc --nomc --notc), @opt_cdifopts } ;
	warn "exec failed: $!";
	print while <>;
	exit;
    }
    ## parent
    else {
	## nothing to do
    }
} else {
    open(DIFF, $DIFF) || die "cannot open diff: $!\n";
}

my $oline = 1;
my $nline = 1;

use constant {
    DIFF_UNDEF => 0,
    DIFF_N => 1,
    DIFF_C => 2,
    DIFF_U => 3,
};
my $diff_mode = DIFF_UNDEF;

while (<DIFF>) {
    my @old;
    my @new;
    my($left, $ctrl, $right);
    #
    # normal diff
    #
    if (($left, $ctrl, $right) = /^([\d,]+)([adc])([\d,]+)$/) {
	$diff_mode = DIFF_N;
	my($l1, $l2) = range($left);
	my($r1, $r2) = range($right);
	if ($readfile) {
	    my $identical_line = $l1 - $oline + 1 - ($ctrl ne 'a');
	    print_identical($identical_line);
	}
	if ($opt_d || $opt_s) {
	    print_command($column_width, $_, $_);
	}
	if ($ctrl eq 'd' || $ctrl eq 'c') {
	    ($oline) = $left =~ /^(\d+)/;
	    my $n = $l2 - $l1 + 1;
	    @old = read_line(*DIFF, $n);
	    $readfile and read_line(*OLD, $n);
	}
	read_line(*DIFF, 1) if $ctrl eq 'c';
	if ($ctrl eq 'a' || $ctrl eq 'c') {
	    ($nline) = $right =~ /^(\d+)/;
	    my $n = $r2 - $r1 + 1;
	    @new = read_line(*DIFF, $n);
	    $readfile and read_line(*NEW, $n);
	}
	map { s/^..// } @old, @new;
	flush_buffer([], \@old, \@new);
    }
    #
    # context diff
    #
    elsif (/^\*\*\* /) {
	$diff_mode = DIFF_C;
	my $next = <DIFF>;
	print_command($column_width, $_, $next, type => 'FILE');
    }
    elsif ($_ eq "***************\n") {
	$diff_mode = DIFF_C;
	my $ohead = $_ = <DIFF>;
	unless (($left) = /^\*\*\* ([\d,]+) \*\*\*\*$/) {
	    print;
	    next;
	}
	my $nhead = $_ = <DIFF>;
	unless (($right) = /^--- ([\d,]+) ----$/) {
	    @old = read_line(*DIFF, range($left) - 1, $nhead);
	    $nhead = $_ = <DIFF>;
	    unless (($right) = /^--- ([\d,]+) ----$/) {
		print $ohead, @old, $_;
		next;
	    }
	}
	if (@old == 0 or grep(/^\!/, @old)) {
	    @new = read_line(*DIFF, scalar(range($right)));
	}
	print_command($column_width, $ohead, $nhead);
	($oline) = $left =~ /^(\d+)/;
	($nline) = $right =~ /^(\d+)/;

	my @buf = merge_diffc(\@old, \@new);
	map { map { s/^..// } @$_ } @buf;
	flush_buffer(@buf);
    }
    #
    # unified diff
    #
    elsif (/^--- /) {
	$diff_mode = DIFF_U;
	my $next = <DIFF>;
	print_command($column_width, $_, $next, type => 'FILE');
    }
    elsif (/^\@\@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? \@\@/) {
	$diff_mode = DIFF_U;
	($oline, $nline) = ($1, $3);
	my($a, $b) = ($2//1, $4//1);
	print_command($column_width, $_, $_, type => 'COMMAND');

	my @buf = read_diffu(*DIFF, $a, $b);
	map { map { s/^.// } @$_ } @buf;
	flush_buffer(@buf);
    }
    else {
	print;
    }
}

close DIFF;
my $exit = $? >> 8;

if ($readfile) {
    if ($exit < 2) {
	print_identical(-1);
    }
    close OLD;
    close NEW;
}

exit($exit == 2);

######################################################################

my %slot;
BEGIN {
    %slot = (" " => 0, "\t" => 0, "-" => 1, "+" => 2);
}
sub read_diffu {
    my $FH = shift;
    my @l = (0, @_);

    my $i = 0;
    my @buf;
    my $slot;
    while (2 * $l[0] + $l[1] + $l[2] > 0) {
	$_ = <$FH>;
	while (($i % 3) != ($slot = $slot{substr($_, 0, 1)})) {
	    $i++;
	}
	$l[$slot]--;
	$buf[$i] //= [];
	push @{$buf[$i]}, $_;
    }
    map { $_ // [] } @buf;
}

sub merge_diffc {
    my @o = @{+shift};
    my @n = @{+shift};
    my @buf;

    die if grep { not /^[ \-\+\!] / } @o, @n;

    while (@o or @n) {
	my @slot = ([], [], []);
	push @buf, @slot;

	if (@o and @n) {
	    while (@o and @n and $o[0] =~ /^  / and $n[0] =~ /^  /) {
		push @{$slot[0]}, shift @o;
		shift @n;
	    }
	}
	elsif (@o) {
	    push @{$slot[0]}, shift @o while @o and $o[0] =~ /^  /;
	}
	elsif (@n) {
	    push @{$slot[0]}, shift @n while @n and $n[0] =~ /^  /;
	}

	push @{$slot[1]}, shift @o while @o and $o[0] =~ /^\- /;
	next if @{$slot[1]};

	push @{$slot[2]}, shift @n while @n and $n[0] =~ /^\+ /;
	next if @{$slot[2]};

	push(@{$slot[1]}, shift @o) while @o and $o[0] =~ /^! /;
	push(@{$slot[2]}, shift @n) while @n and $n[0] =~ /^! /;
    }

    @buf;
}

sub flush_buffer {

    push @_, [] while @_ % 3;
    while (my($s, $o, $n) = splice(@_, 0, 3)) {

	for (@$s) {
	    print_column($column_width, $_, ' ', ' ', $_);
	    $oline++;
	    $nline++;
	}

	while (@$o or @$n) {
	    my $old = shift @$o;
	    my $new = shift @$n;
	    my $omark = $old ? '<' : ' ';
	    my $nmark = $new ? '>' : ' ';

	    print_column($column_width, $old, $omark, $nmark, $new);

	    $oline++ if defined $old;
	    $nline++ if defined $new;
	}
    }
}

sub print_identical {
    my $n = shift;
    while ($n--) {
	my $old = <OLD>;
	my $new = <NEW>;
	defined $old or defined $new or last;
	if ($opt_l) {
	    print linenum($oline) if $opt_n;
	    print expand_tab($old);
	} else {
	    print_column($column_width, $old, ' ', ' ', $new);
	}
	$oline++; $nline++;
    }
}

my $num_width;
my $num_format;
BEGIN {
    $num_width = 4;
    $num_format = "%${num_width}d";
}
sub linenum {
    my $n = shift;
    defined $n ? (sprintf $num_format, $n) : (' ' x $num_width);
}

sub print_column {
    my($width, $old, $omark, $nmark, $new, $noline) = @_;
    my $print_number = ($opt_n and not $noline);

    my($onum, $nnum, $nspace) = ('', '', '');
    if ($print_number) {
	$onum = ' ' x $num_width;
	$nnum = ' ' x $num_width;
	$nspace = ' ',
	$width = max(1, $width - $num_width - length($nspace));
    }
    if (defined $old) {
	chomp $old;
	$old = expand_tab($old);
	$onum = linenum($oline) if $print_number;
    }
    if (defined $new) {
	chomp $new;
	$new = expand_tab($new);
	$nnum = linenum($nline) if $print_number;
    }

    $omark =~ s/[<>]/>/ if $omarkpos eq LEFT;
    $omark =~ s/[<>]/</ if $omarkpos eq RIGHT;
    $nmark =~ s/[<>]/>/ if $nmarkpos eq LEFT;
    $nmark =~ s/[<>]/</ if $nmarkpos eq RIGHT;

    my($OTEXT, $OLINE, $OMARK) =
	$omark =~ /\S/ ? qw(OTEXT OLINE OMARK) : qw(UTEXT ULINE UMARK);
    my($NTEXT, $NLINE, $NMARK) =
	$nmark =~ /\S/ ? qw(NTEXT NLINE NMARK) : qw(UTEXT ULINE UMARK);

    my $expand_right = $colormap{NTEXT} =~ /E/ || $nmarkpos eq RIGHT;

    my($o, $n);
    while (1) {
	($o, $old) = fold($old // "", $width, onword => $opt_onword,
			  pad => 1);
	($n, $new) = fold($new // "", $width, onword => $opt_onword,
			  pad => $expand_right);

	my %f;
	$f{OMARK} = $colorize->($OMARK, $omark);
	$f{OLINE} = $colorize->($OLINE, $onum) . " " if $print_number;
	$f{OTEXT} = $colorize->($OTEXT, $o) if $o ne "";
	$f{NMARK} = $colorize->($NMARK, $nmark);
	$f{NLINE} = $colorize->($NLINE, $nnum) . " " if $print_number;
	$f{NTEXT} = $colorize->($NTEXT, $n) if $n ne "";
	print_fields(\%f);

	last if $opt_truncate;
	last unless $old ne '' or $new ne '';

	if ($print_number) {
	    $onum = $nnum = linenum(undef);
	}
	$omark = $old ne '' ? '.' : ' ';
	$nmark = $new ne '' ? '.' : ' ';
    }
}

sub print_command {
    my($width, $old, $new) = splice(@_, 0, 3);
    my %opt = @_;

    if (defined $old) {
	chomp $old;
	$old = expand_tab($old);
    }
    if (defined $new) {
	chomp $new;
	$new = expand_tab($new);
    }
    my($o, $ox) = fold($old, $width, pad => 1);
    my($n, $nx) = fold($new, $width, pad => 1);

    my($ocolor, $ncolor) = qw(OCOMMAND NCOMMAND);
    if ($opt{type}) {
	$ocolor = "O" . $opt{type};
	$ncolor = "N" . $opt{type};
    }

    print_fields({OMARK => " ", NMARK => " ",
		  OTEXT => $colorize->($ocolor, $o),
		  NTEXT => $colorize->($ncolor, $n),
		 });
}

sub print_fields {
    my $F = shift;
    local $_;
    $_ = $F->{OMARK} and print if $omarkpos eq LEFT;
    $_ = $F->{OLINE} and print;
    $_ = $F->{OTEXT} and print;
    $_ = $F->{OMARK} and print if $omarkpos eq RIGHT;
    $_ = $F->{NMARK} and print if $nmarkpos eq LEFT;
    $_ = $F->{NLINE} and print;
    $_ = $F->{NTEXT} and print;
    $_ = $F->{OMARK} and print if $nmarkpos eq RIGHT;
    print "\n";
}

my $wchars;
my $_a_zA_Z0_9;
my $reset_re;
my $color_re;
BEGIN {
    my $wide      = '\p{East_Asian_Width=Wide}';
    my $fullwidth = '\p{East_Asian_Width=FullWidth}';
    my $ambiguous = '\p{East_Asian_Width=Ambiguous}';
    $wchars = "${wide}${fullwidth}";
    $_a_zA_Z0_9 = "_a-zA-Z0-9";
    $reset_re = qr/\e\[[0;]*m/;
    $color_re = qr/\e\[[\d;]*m/;
}

sub fold {
    local $_ = shift;
    my $width = shift;
    my %opt = @_ ? @_ : {};

    $width < 1 and croak "width should be greater than 0";

    my $folded = '';
    my $room = $width;
    my @color_stack;
    while (length) {

	if (s/^($reset_re)//) {
	    $folded .= $1;
	    @color_stack = ();
	    next;
	}

	last if $room < 1;
	last if $room != $width and /^[$wchars]/o and $room < 2;

	if (s/^($color_re)//) {
	    $folded .= $1;
	    push @color_stack, $1;
	    next;
	}

	if (my $mb = s/^([$wchars]+)//o or s/^(\e*[^\e$wchars]+)//o) {
	    my $string = $1;
	    my $chars = $mb ? max(1, int($room/2)) : $room;

	    my $cut = substr($string, 0, $chars, "");
	    $folded .= $cut;
	    $room -= mbwidth($cut);
	    $_ = $string . $_ if length $string;
	} else {
	    die "panic ($_)";
	}
    }

    if ($opt{onword}
	and my($tail) = /^([$_a_zA_Z0_9]+)/o
	and $folded =~ m{
		^
		( (?: [^\e]* $color_re ) *+ )
		( .*? )
		( [$_a_zA_Z0_9]+ )
		$
	}xo
	) {
	## Break line before word only when enough space will be
	## provided for the word in the next call.
	my($s, $e) = ($-[3], $+[3]);
	my $l = $e - $s;
	if ($room + $l < $width and $l + length($tail) <= $width) {
	    $_ = substr($folded, $s, $l, '') . $_;
	    $room += $l;
	}
    }

    if (@color_stack) {
	$folded .= RESET;
	$_ = join '', @color_stack, $_;
    }

    $folded .= ' ' x $room if $opt{pad};

    ($folded, $_);
}

sub read_line {
    local *FH = shift;
    my $c = shift;
    my @buf = @_;
    while ($c--) {
	last if eof FH;
	push @buf, scalar <FH>;
    }
    wantarray ? @buf : join '', @buf;
}

sub range {
    local $_ = shift;
    my($from, $to) = /,/ ? split(/,/) : ($_, $_);
    wantarray ? ($from, $to) : $to - $from + 1;
}

my @tabspace;
BEGIN {
    @tabspace = map { ' ' x (8 - $_) } 0..7;
}
sub expand_tab {
    local $_ = shift;
    1 while s/^([^\t]*)\t/$1 . $tabspace[&pwidth($1) % 8]/e;
    $_;
}

sub pwidth {
    local $_ = shift;
    if (/[\010\e\f\r]/) {
	s/$color_re//g;
	s/^.*[\f\r]//;
	1 while s/[^\010]\010//;
	s/^\010+//;
    }
    /[$wchars]/o ? mbwidth($_) : length($_);
}

sub mbwidth {
    my $arg = shift;
    my $len = length $arg;
    while ($arg =~ m/([$wchars]+)/go) {
	$len += length $1;
    }
    $len;
}

sub terminal_width {
    my $width = 80;
    if (-t STDERR) {
	my $stty = `stty -f /dev/stderr all`; # XXX too easy...
	if ($stty =~ /(\d+) +columns/) {
	    $width = $1 if $1;
	}
    }
    $width;
}

sub unesc {
    local $_ = shift;
    s/\e/\\e/g;
    $_;
}

sub colorseq {
    my $colormode = shift;

    my($start, $end) = ('', '');
    if ($colormode =~ /,/) {
	($start, $end) = split(/,/, $colormode, 2);
    } else {
	map {
	    $start .= UNDERLINE if /U/;
	    $start .= REVERSE   if /S/;
	    $start .= BOLD      if /D/;
	    $start .= BLINK     if /F/;
	    $start .= RED       if /R/; $start .= ON_RED       if /r/;
	    $start .= GREEN     if /G/; $start .= ON_GREEN     if /g/;
	    $start .= BLUE      if /B/; $start .= ON_BLUE      if /b/;
	    $start .= CYAN      if /C/; $start .= ON_CYAN      if /c/;
	    $start .= MAGENTA   if /M/; $start .= ON_MAGENTA   if /m/;
	    $start .= YELLOW    if /Y/; $start .= ON_YELLOW    if /y/;
	    $start .= BLACK     if /K/; $start .= ON_BLACK     if /k/;
	    $start .= WHITE     if /W/; $start .= ON_WHITE     if /w/;
	} $colormode if $colormode;
	$end = RESET if $start;
	$start =~ s/m\e\[/;/g;
    }
    ($start, $end);
}

my %colorcache;

sub color {
    my($color, $text) = @_;
    return $text unless $color;
    unless ($colorcache{$color}) {
	my $mode = exists $colormap{$color} ? $colormap{$color} : $color;
	$colorcache{$color} = [ colorseq($mode) ];
    }
    my($s, $e) = @{$colorcache{$color}};
    if ($s ne "") {
	$text =~ s/(^|$reset_re)([^\e\r\n]+)/$1$s$2$e/mg;
    }
    $text;
}

__END__

=pod

=head1 DESCRIPTION

Sdif is inspired by System V sdiff(1) command.  The basic feature of
sdif and sdiff is making a side-by-side listing of two different
files.  All contents of two files are listed on left and right sides.
Center column is used to indicate how different the line.  No mark
means there is no difference.  Added, deleted and modified lines are
marked with `<' and `>' character.

    1 deleted  <
    2 same          1 same
    3 changed  <>   2 modified
    4 same          3 same
                >   4 added

=head1 OPTIONS

=over 7

=item B<--w>=I<width>, -w

Use width as a width of output listing.  Default width is 80.  If the
standard error is assinged to a terminal, the width is taken from it
if possible.

=item B<--number>, B<-n>

Print line number on each lines.

=item B<--truncate>, B<-t>

Truncate lines if they are longer than printing width.

=item B<--onword>

Fold longs line at word boundaries.

=item B<--cdif>

Use B<cdif> command instead of normal diff command.

=item B<-b>, B<-w>, B<-B>, B<-c>, B<-C>, B<-u>, B<-U>

Passed through to the back-end diff command.  Sdif can interpret the
output from normal, context (I<diff -c>) and unified diff (I<diff
-u>).

=item B<--diff>=I<command>

Any command can be specified as a diff command to be used.  Piping
output to B<sdif> is easier unless you want to get whole text.

=item B<--mark>=I<position>

Specify the position for mark.  Choose from I<left>, I<right>,
I<center>, I<side> or I<no>.  Default is I<center>.

=item B<-->[B<no>]B<color>

Use ANSI color escape sequence for output.  Default is true.

=item B<--colormap>=I<colormap>, B<--cm>=I<colormap>

Basic I<colormap> format is :

    FIELD=COLOR

where the FIELD is one from these :

    OCOMMAND Old command line
    NCOMMAND Old command line
    OFILE    Old filename
    NFILE    New filename
    OMARK    Old mark
    NMARK    New mark
    UMARK    Unchanged mark
    OLINE    Old line
    NLINE    New line
    ULINE    Unchanged line
    OTEXT    Old text
    NTEXT    New text
    UTEXT    Unchanged text

You can make multiple filelds same color joining them by = :

    FIELD1=FIELD2=...=COLOR

Also wildcard can be used for field name :

    *CHANGE=BDw

Multiple fields can be specified by repeating options

    --cm FILED1=COLOR1 --cm FIELD2=COLOR2 ...

or combined with comma (,) :

    --cm FILED1=COLOR1,FIELD2=COLOR2, ...

COLOR is combination of single character representing uppercase
foreground color :

    R  Red
    G  Green
    B  Blue
    C  Cyan
    M  Magenta
    Y  Yellow
    K  Black
    W  White

and corresponding lowercase background color :

    r, g, b, c, m, y, k, w

and other effects :

    S  Standout (reverse video)
    U  Underline
    D  Double-struck (boldface)
    F  Flash (blink)
    E  Expand

B<E> is effective for command, file and text line.  That line will be
expanded to window width filling up by space characters.  Left column
is expanded always.  You may want to use this to set background color
for right column.

Defaults are :

    OCOMMAND => "CSE"
    NCOMMAND => "MSE"
    OFILE    => "CDE"
    NFILE    => "MDE"
    OMARK    => "Cw"
    NMARK    => "Mw"
    UMARK    => "w"
    OLINE    => "Y"
    NLINE    => "Y"
    ULINE    => "Y"
    OTEXT    => "C"
    NTEXT    => "M"
    UTEXT    => ""

This is equivalent to :

    sdif --cm 'OCOMMAND=CSE,NCOMMAND=MSE,OFILE=CDE,NFILE=MDE' \
         --cm 'OMARK=Cw,NMARK=Mw,UMARK=w' \
         --cm '*LINE=Y,OTEXT=C,NTEXT=M,UTEXT='

Try next setting if you want to make modified section more visible.

    sdif -n --cdif --cm '[ON]TEXT=wE,UMARK=,OMARK=C,NMARK=M'

=head1 AUTHOR

Kazumasa Utashiro

https://github.com/kaz-utashiro/

=head1 SEE ALSO

perl(1),
diff(1),
cdif(1)

=cut
