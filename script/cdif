#!/usr/bin/perl

use strict;
use warnings;
require 5.010;

use utf8;
use Encode;
use Encode::Guess;

use Getopt::Long;
use Pod::Usage;
use Text::ParseWords qw(shellwords);

##
## cdif: word context diff
##
## Copyright (c) 1992-2013 Kazumasa Utashiro
##
;; my $rcsid = q$Id: cdif,v 2.4 2013/12/27 07:13:15 utashiro Exp $;
## Original: 1992/03/11
##
## Use and redistribution for ANY PURPOSE are granted as long as all
## copyright notices are retained.  Redistribution with modification
## is allowed provided that you make your modified version obviously
## distinguishable from the original one.  THIS SOFTWARE IS PROVIDED
## BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE
## DISCLAIMED.
##

##
## options
##
my $opt_B;
my $opt_c;
my $opt_u;
my $opt_b;
my $opt_i;
my $opt_d = 0;
my $opt_q;
my $opt_n;
my $opt_t;
my $opt_s;
my $opt_w;
my $opt_color = 1;
my $opt_keeptmpfile;

my $rcs;
my @rcsopt;
my $diff;
my @diffopts;
my @sub_diffopts;

my $opt_expand = 1;
my $expand_width = terminal_width();

my %colormap = (
    MARK_OLD  =>  "CS",
    MARK_NEW  =>  "MS",
    CONTROL   =>  "S",
    APPEND    =>  "RDw",
    DELETE    =>  "RDw",
    OLD       =>  "BDw",
    NEW       =>  "BDw",
    );

binmode STDOUT, ":encoding(utf8)";

if ($ENV{'CDIFOPTS'}) {
    unshift(@ARGV, shellwords($ENV{'CDIFOPTS'}));
}

my @optargs = (
    "d+" => \$opt_d,
    "B|char" => \$opt_B,
    "diff=s" => \$diff,
    "color!" => \$opt_color,
    "colormap|cm=s" => \%colormap,
    "keeptmpfile" => \$opt_keeptmpfile,
    "h" => sub { usage() },
    "man" => sub { pod2usage({-verbose => 2}) },
    "t=s" => \$opt_t,

    "i" => \$opt_i,
    "b" => \$opt_b,
    "w" => \$opt_w,
    "c" => sub { push(@diffopts, "-c") },
    "u" => sub { push(@diffopts, "-u") },
    "C=i" => sub { push(@diffopts, "-C" . ($_[1] > 0 ? $_[1] : '')) },
    "U=i" => sub { push(@diffopts, "-U" . ($_[1] > 0 ? $_[1] : '')) },

    "rcs" => \$rcs,
    "r=s" => sub { push @rcsopt, "-r$_[1]" },
    "q" => sub { push @rcsopt, "-q" },
);

Getopt::Long::Configure("bundling");
GetOptions(@optargs) || usage();

$rcs++ if @rcsopt;
$diff = $rcs ? 'rcsdiff' : 'diff' unless $diff;

push(@sub_diffopts,
     $opt_i ? "-i" : (),
     $opt_w ? "-w" : (),
    );

sub usage {
    pod2usage;
    exit;
}

my $DIFF;
my $OLD;
my $NEW;

if ($rcs) {
    my $rcsfile = shift || usage("No RCS filename\n\n");
    $DIFF = "$diff @diffopts @rcsopt $rcsfile|";
} elsif (@ARGV == 2) {
    ($OLD, $NEW) = splice(@ARGV, 0, 2);
    $DIFF = "$diff @diffopts $OLD $NEW |";
} elsif (@ARGV < 2) {
    $DIFF = shift || '-';
} else {
    usage("Arguments error.\n\n") if @ARGV;
}
print "DIFF=\"$DIFF\"\n" if $opt_d;

my %func = $opt_color ?
    (
     APPEND => sub { color("APPEND", @_) },
     DELETE => sub { color("DELETE", @_) },
     OLD    => sub { color("OLD",    @_) },
     NEW    => sub { color("NEW",    @_) },
    ) :
    (
     APPEND => \&bd,
     DELETE => \&bd,
     OLD    => \&ul,
     NEW    => \&ul,
    );

my $wchar_re = qr{
    [ \p{East_Asian_Width=Wide} \p{East_Asian_Width=FullWidth} ]
}x;

my $w_pattern;
if ($opt_B) {
    $w_pattern = qr/./s;
} else {
    $w_pattern = qr{
	\p{Han}+ | \p{InHiragana}+ | \p{InKatakana}+ |
	\p{Hang}+ |
	[a-zA-Z0-9_]+ | [ \t\r\f]*\n | \s+ | (.)\g{-1}*
    }x;
}
my @ul = ("", "_\010", "__\010\010");
my @bs = ("", "\010", "\010\010");

##
## Temporary file names
##
my $tmp = $opt_t || '/tmp';
my $TBASE = "$tmp/cdif_$$";
my($T1, $T2) = ("${TBASE}_1", "${TBASE}_2");

@SIG{'INT', 'HUP', 'QUIT', 'TERM'} = ('cleanup') x 4;

##
## Total statistic info
##
my %stat;
@stat{'a', 'd', 'c', 'anl', 'dnl', 'cnl'} = (0, 0, 0, 0, 0, 0);
@stat{'anlb', 'dnlb', 'cnlb'} = (0, 0, 0);

open(DIFF, $DIFF) || die "$DIFF: $!\n";
binmode DIFF, ":encoding(utf8)";

while (<DIFF>) {
    my($so, $se) = colorseq('S');
    my($left, $right);
    #
    # normal diff
    #
    if (($left, $right) = /^([\d,]+)[ad]([\d,]+)\r?$/) {
	print_control($_);
    }
    elsif (($left, $right) = /^([\d,]+)c([\d,]+)\r?$/) {
	print_control($_);
	my $old = read_diff(*DIFF, scalar(range($left)));
	my $del = read_diff(*DIFF, 1);
	my $new = read_diff(*DIFF, scalar(range($right)));

	$old =~ s/^< //mg;
	$new =~ s/^> //mg;

	($old, $new) = context($old, $new);

	if ($opt_color) {
	    $old =~ s/^/color("MARK_OLD", "< ")/mge;
	    $new =~ s/^/color("MARK_NEW", "> ")/mge;
	} else {
	    $old =~ s/^/< /mg;
	    $new =~ s/^/> /mg;
	}

	print $old, $del, $new;
    }
    #
    # diff -c
    #
    elsif (($left) = /^\*\*\* ([\d,]+) \*\*\*\*\r?$/) {
	print_control($_);
	my(@old, @new);
	@old = read_diffc(*DIFF, scalar(range($left)));
	if (@old < 2) {
	    print @old;
	    next;
	}
	my $new = $_ = <DIFF>;
	if (($right) = /^--- ([\d,]+) ----$/) {
	    @new = read_diffc(*DIFF, scalar(range($right)));
	    for my $i (0 .. $#old) {
		if ($i % 2) {
		    $old[$i] =~ s/^! //mg;
		    $new[$i] =~ s/^! //mg;

		    ($old[$i], $new[$i]) = context($old[$i], $new[$i]);

		    $old[$i] =~ s/^/! /mg;
		    $new[$i] =~ s/^/! /mg;
		}
		if ($opt_color) {
		    $old[$i] =~ s/^([\-\!] )/color("MARK_OLD", $1)/mge;
		    $new[$i] =~ s/^([\+\!] )/color("MARK_NEW", $1)/mge;
		}
	    }
	}
	print @old, $new, @new;
    }
    #
    # diff -u
    #
    elsif (/^\@\@ -\d+(,(\d+))? \+\d+(,(\d+))? \@\@/)  {
	print_control($_);
	my @buf = read_diffu(*DIFF, $2 || 1, $4 || 1);
	while (my($same, $old, $new) = splice(@buf, 0, 3)) {
	    print $same;
	    if ($old and $new) {
		$old =~ s/^\-//mg;
		$new =~ s/^\+//mg;

		($old, $new) = context($old, $new);

		$old =~ s/^/-/mg;
		$new =~ s/^/+/mg;
	    }
	    if ($opt_color) {
		$old =~ s/^\-/color("MARK_OLD", "-")/mge if $old;
		$new =~ s/^\+/color("MARK_NEW", "+")/mge if $new;
	    }
	    print $old if $old;
	    print $new if $new;
	}
    }
    else {
	print;
    }
}
close DIFF;

if ($opt_s) {
    select STDERR;

    print("TOTAL:             ");
    printf("append=%d delete=%d change=%d\n",
	   $stat{'a'}, $stat{'d'}, $stat{'c'});
    print("INGORE WHITESPACE: ");
    printf("append=%d delete=%d change=%d\n",
	   $stat{'anl'},
	   $stat{'dnl'},
	   $stat{'cnl'});
    print("INGORE WHITESPACE (bytes): ");
    printf("append=%d delete=%d change=%d\n",
	   $stat{'anlb'},
	   $stat{'dnlb'},
	   $stat{'cnlb'});
}

exit $? >> 8;

######################################################################

sub print_control {
    my $line = shift;
    if ($opt_color) {
	if ($opt_expand and length($line) < $expand_width) {
	    $line =~ s/$/' ' x ($expand_width - length($_))/e
	}
	$line = color($colormap{CONTROL}, $line);
    }
    print $line;
}

my $tmp_sequence = 0;

sub context {
    my($old, $new) = @_;
    local $_;

    if ($opt_keeptmpfile) {
	$tmp_sequence++;
	$T1 = sprintf("%s_%04d_1", $TBASE, $tmp_sequence);
	$T2 = sprintf("%s_%04d_2", $TBASE, $tmp_sequence);
    }

    if ($opt_d >= 2) {
	print STDERR "****************************** Comparing ...\n";
	print STDERR $old;
	print STDERR "****************************** and\n";
	print STDERR $new;
	print STDERR "****************************** .\n";
    }

    my %c = (a => 0, d => 0, c => 0);
    my @owlist = &maketmp($T1, $old);
    my @nwlist = &maketmp($T2, $new);
    my @control = ();

    open(CDIF, "diff @sub_diffopts $T1 $T2 |") || die "diff: $!\n";
    binmode CDIF, ":encoding(utf8)";
    while (<CDIF>) {
	print if $opt_d >= 2;
	if (/^[\d,]+([adc])[\d,]+$/) {
	    push @control, $_;
	    $c{$1}++;
	}
    }
    close CDIF;
    cleanup() unless $opt_keeptmpfile;

    if ($opt_d >= 1) {
	printf "old=%d new=%d control=%d\n", @owlist+0, @nwlist+0, @control+0;
	printf "append=$c{a} delete=$c{d} change=$c{c}\n";
    }

    my($obuf, $nbuf) = makebuf(\@owlist, \@nwlist, \@control);
    die "illegal status of subprocess\n" if ($?>>8) > 1;

    ($obuf, $nbuf);
}

sub cleanup {
    unlink $T1;
    unlink $T2;
    if (@_) {
	warn "\nSignal @_\n";
	exit 2;
    }
}

##
## Divide given text into word list.  Then write them into temporary
## file `$file' which include the word list one on each line.  The list
## itself is returned as a result of subroutine.
##
sub maketmp {
    my $tmp_file = shift;
    my $text = shift;
    my @words;
    my @notspace = (0);

    open(TMP, ">$tmp_file") || warn "$tmp_file: $!\n", return 0;
    binmode TMP, ":encoding(utf8)";

    while ($text =~ /($w_pattern)/g) {
	local $_ = $1;
	if ($opt_w) {
	    push(@notspace, !/\s/);
	    if (shift(@notspace) && $notspace[0]) {
		push(@words, '');
		print TMP "\n";
	    }
	}
	if (s/^(\s*)\n/\n/ && (length($1) || $opt_b || $opt_w)) {
	    #     ^ This have to be *.  Don't change to +.
	    print TMP ($opt_b || $opt_w) ? "\n" : "$1\n";
	    push(@words, $1);
	}
	push @words, $_;
	print TMP $_;
	print TMP "\n" unless /\n$/;
    }
    close TMP;

    if ($opt_d && @words != &wc_l($tmp_file)) {
	die "Error! (\@words != `wc -l $tmp_file`)\n";
    }

    @words;
}

##
##  @owlist: old word list
##  @nwlist: new word list
##  @control: how different these lists (`diff' result control lines)
##
sub makebuf {
    my($ol, $nl, $ctrl) = @_;
    my @owlist = @$ol;
    my @nwlist = @$nl;
    my @control = @$ctrl;

    my($o, $n) = (0, 0);	# pointers
    my(@obuf, @nbuf);

    for (@control) {
	my($old, $ctrl, $new) = /([\d,]+)([adc])([\d,]+)/ or do {
	    die "Panic! Unexpected diff output";
	};
	my($o1, $o2) = range($old);
	my($n1, $n2) = range($new);
	map { $_-- } $o1, $o2, $n1, $n2; # make them zero origined

	push(@obuf, @owlist[$o .. $o1 - 1]), $o = $o1 if $o < $o1;
	push(@nbuf, @nwlist[$n .. $n1 - 1]), $n = $n1 if $n < $n1;

	$stat{$ctrl}++;

	if ($ctrl eq 'd') {
	    if ($owlist[$o2] =~ /\S/) {
		$stat{'dnl'}++;
		$stat{'dnlb'} += length(join('', @owlist[$o1 .. $o2]));
	    }
	    push(@obuf, $func{DELETE}->(@owlist[$o1 .. $o2]));
	    $o = $o2 + 1;
	}
	elsif ($ctrl eq 'c') {
	    if (($owlist[$o2] =~ /\S/) || ($nwlist[$n2] =~ /\S/)) {
		$stat{'cnl'}++;
		$stat{'cnlb'} += length(join('', @owlist[$o1 .. $o2]));
		$stat{'cnlb'} += length(join('', @nwlist[$n1 .. $n2]));
	    }
	    push(@obuf, $func{OLD}->(@owlist[$o1 .. $o2]));
	    push(@nbuf, $func{NEW}->(@nwlist[$n1 .. $n2]));
	    $o = $o2 + 1;
	    $n = $n2 + 1;
	}
	elsif ($ctrl eq 'a') {
	    if ($nwlist[$n2] =~ /\S/) {
		$stat{'anl'}++;
		$stat{'anlb'} += length(join('', @nwlist[$n1 .. $n2]));
	    }
	    push(@nbuf, $func{APPEND}->(@nwlist[$n1 .. $n2]));
	    $n = $n2 + 1;
	}
    }
    push(@obuf, @owlist[$o .. $#owlist]);
    push(@nbuf, @nwlist[$n .. $#nwlist]);

    (join('', @obuf), join('', @nbuf));
}

sub read_diff {
    my($FH, $c) = @_;
    my @buf;
    while ($c-- > 0) {
	push @buf, scalar <$FH>;
    }
    wantarray ? @buf : join '', @buf;
}

sub read_diffc {
    my($FH, $n) = @_;
    my @buf;
    local $_;
    for (my $i = 0; $n-- && ($_ = <$FH>); $buf[$i] .= $_) {
	$i++ if ($i % 2) != /^!/;
    }
    map { $_ // "" } @buf;
}

sub read_diffu {
    my $FH = shift;
    my @l = (0, @_);

    my $i = 0;
    my @buf;
    my $slot;
    my %slot = (' ' => 0, '-' => 1, '+' => 2);
    for (; 2 * $l[0] + $l[1] + $l[2] > 0 && ($_ = <$FH>); $buf[$i] .= $_) {
	$i++ while ($i % 3) != ($slot = $slot{substr($_, 0, 1)});
	$l[$slot]--;
    }
    map { $_ // "" } @buf;
}

## 
## Copied from MBprintf.pm
## 
sub mbwidth {
    my $arg = shift;
    my $len = length($arg);
    while ($arg =~ m/($wchar_re+)/go) {
	$len += length($1);
    }
    $len;
}

sub ul {
    local $_ = join '', @_;
    s/(.)/$ul[mbwidth($1)].$1/ge;
    $_;
}
sub bd {
    local $_ = join '', @_;
    s/(\S)/$1.$bs[mbwidth($1)].$1/ge;
    $_;
}

sub range {
    local $_ = shift;
    my($from, $to) = @_;
    ($from, $to) = /,/ ? split(/,/) : ($_, $_);
    wantarray ? ($from, $to) : $to - $from + 1;
}

use Term::ANSIColor qw(:constants);

sub colorseq {
    my $colormode = shift;

    my($start, $end) = ('', '');
    if ($colormode =~ /,/) {
	($start, $end) = split(/,/, $colormode, 2);
    } else {
	map {
	    $start .= UNDERLINE if /U/;
	    $start .= REVERSE   if /S/;
	    $start .= BOLD      if /D/;
	    $start .= RED       if /R/; $start .= ON_RED       if /r/;
	    $start .= GREEN     if /G/; $start .= ON_GREEN     if /g/;
	    $start .= BLUE      if /B/; $start .= ON_BLUE      if /b/;
	    $start .= CYAN      if /C/; $start .= ON_CYAN      if /c/;
	    $start .= MAGENTA   if /M/; $start .= ON_MAGENTA   if /m/;
	    $start .= YELLOW    if /Y/; $start .= ON_YELLOW    if /y/;
	    $start .= WHITE     if /W/; $start .= ON_WHITE     if /w/;
	} $colormode if $colormode;
	$end = RESET if $start;
	$start =~ s/m\e\[/;/g;
    }
    ($start, $end);
}

my %colorcache;

sub color {
    my $color = shift;
    my $text = join '', @_;
    my $cache;
    unless ($cache = $colorcache{$color}) {
	my $mode = $colormap{$color} || $color;
	$colorcache{$color} = [ colorseq($mode) ];
    }
    my($s, $e) = @{$colorcache{$color}};
    $text =~ s/([^\r\n]+)/$s$1$e/g;
    $text;
}

sub wc_l {
    my $file = shift;
    my $line;
    local *FILE;
    open(FILE, $file) || die "$file: $!\n";
    $line++ while <FILE>;
    close FILE;
    $line;
}

sub eval {
    print STDERR &unctrl($_[0]), "\n" x ($_[0] !~ /\n$/) if $_[1] || $opt_d;
    eval shift;
    die sprintf("eval failed in file %s on line %s\n$@", (caller)[1,2]) if $@;
}

sub unctrl {
    local $_ = shift;
    s/([\000-\010\013-\037])/'^' . pack('c', ord($1)|0100)/ge;
    $_;
}

sub terminal_width {
    my $width = 80;
    if (-t STDERR) {
	my $stty = `stty -f /dev/stderr all`; # XXX too easy...
	if ($stty =~ /(\d+) +columns/) {
	    $width = $1;
	}
    }
    $width;
}

######################################################################

=head1 NAME

cdif - word context diff

=head1 SYNOPSIS

cdif [ -[Bs] ] [ -[bwcu] ] file1 file2

cdif [-rcs] [-q] [-rrev1 [-rrev2]] [cdif options] file

cdif [cdif options] [diff-output-file]

Options:

	-B		char-by-char compare
	-b		ignore trailing blank
	-w		ignore whitespace
	-c		context diff
	-u		unified diff
	-s		show statistical information at the end
	--[no]color	use/no color (dfault ON)
	--diff=command	specify any diff command
	--rcs		use rcsdiff
	-r<rev>, -q	rcs options

=head1 DESCRIPTION

B<Cdif> is a post-processor of the Unix diff command.  It highlights
deleted, changed and added words based on word context.

Appended and deleted lines are not effected at all.

You may want to compare character-by-character rather than
word-by-word.  Option B<-B> option can be used for that purpose.

If only one file is specified, cdif reads that file (stdin if no file)
as a output from diff command.  This is convenient because you don't
have to retype the command line.

Lines those don’t look like diff output are simply ignored and
printed same as input.

=head1 OPTIONS

=over 7

=item B<-B>, B<--char>

Compare the data character-by-character context.

=item B<--nocolor>

Do not use ANSI color escape sequence for output.

=item B<--diff>=I<command>

Specify the diff command to use.

=item B<--rcs>, B<-r>I<rev>

Use rcsdiff instead of normal diff.  Option B<--rcs> is not required
when B<-r>I<rev> is supplied.

=item B<-b>, B<-w>, B<-c>, B<-u>

Passed through to the back-end diff command.  B<cdif> can process the
output from context diff (B<-c>) and unified diff (B<-u>) if those are
available.

=item B<-s>

Print statistical information at the end of output.  It shows number
of total appended/deleted/changed words in the context of cdif.  It’s
common to have many inserts and deletes of newlines becuase of text
filling process.  So normal informaiton is followed by modified number
which ignores insert/delete newlines.

=back

=head1 AUTHOR

Kazumasa Utashiro

https://github.com/kaz-utashiro/

=head1 SEE ALSO

perl(1), diff(1), sdif(1)

=head1 BUGS

When the last word (the last byte with B<-B> option) of a line moved
to the next line, it is treated as disappeared and the new word was
appeared.  This is due to the behavior of diff command.

B<cdif> is naturally slow because it uses normal diff command as a
backend processor to compare words.

=head1 COPYRIGHT

Use and redistribution for ANY PURPOSE are granted as long as all
copyright notices are retained.  Redistribution with modification is
allowed provided that you make your modified version obviously
distinguishable from the original one.  THIS SOFTWARE IS PROVIDED BY
THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE
DISCLAIMED.
