#!/usr/bin/perl

use strict;
use warnings;
require 5.010;

use utf8;
use Encode;
use Encode::Guess;

use Getopt::Long;
use Pod::Usage;
use Text::ParseWords qw(shellwords);
use Text::Glob qw(match_glob);
use Data::Dumper;
$Data::Dumper::Terse = 1;

##
## cdif: word context diff
##
## Copyright (c) 1992-2014 Kazumasa Utashiro
##
;; my $rcsid = q$Id: cdif,v 2.5 2014/01/02 05:19:04 utashiro Exp $;
## Original: 1992/03/11
##
## Use and redistribution for ANY PURPOSE are granted as long as all
## copyright notices are retained.  Redistribution with modification
## is allowed provided that you make your modified version obviously
## distinguishable from the original one.  THIS SOFTWARE IS PROVIDED
## BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE
## DISCLAIMED.
##

##
## options
##
my $opt_B;
my $opt_d = 0;
my $opt_q;
my $opt_n;
my $opt_tmp;

my $opt_stat;
my $opt_color = 1;
my @opt_colormap;
my $opt_keeptmpfile;
my $opt_commandcolor = 1;
my $opt_markcolor = 1;
my $opt_textcolor = 1;

my $opt_c;
my $opt_u;
my $opt_i;
my $opt_b;
my $opt_w;
my $opt_t;
my $opt_T;

my $rcs;
my @rcsopt;
my $diff;
my @diffopts;
my @sub_diffopts;

binmode STDOUT, ":encoding(utf8)";

if ($ENV{'CDIFOPTS'}) {
    unshift(@ARGV, shellwords($ENV{'CDIFOPTS'}));
}

my @optargs = (
    "d+" => \$opt_d,
    "B|char" => \$opt_B,
    "diff=s" => \$diff,
    "color!" => \$opt_color,
    "commandcolor|cc!" => \$opt_commandcolor,
    "markcolor|mc!" => \$opt_markcolor,
    "textcolor|tc!" => \$opt_textcolor,
    "colormap|cm=s" => \@opt_colormap,
    "keeptmpfile" => \$opt_keeptmpfile,
    "h|help" => sub { pod2usage() },
    "man" => sub { pod2usage({-verbose => 2}) },
    "stat" => \$opt_stat,
    "tmp=s" => \$opt_tmp,

    "i|ignore-case" => \$opt_i,
    "b|ignore-space-change" => \$opt_b,
    "w|ignore-all-space" => \$opt_w,
    "t|expand-tabs" => \$opt_t,
    "T|initial-tab" => \$opt_T,
    "c|context" => sub { push(@diffopts, "-c") },
    "u|unified" => sub { push(@diffopts, "-u") },
    "C=i" => sub { push(@diffopts, "-C" . ($_[1] > 0 ? $_[1] : '')) },
    "U=i" => sub { push(@diffopts, "-U" . ($_[1] > 0 ? $_[1] : '')) },

    "rcs" => \$rcs,
    "r=s" => sub { push @rcsopt, "-r$_[1]" },
    "q" => sub { push @rcsopt, "-q" },
);

Getopt::Long::Configure("bundling");
GetOptions(@optargs) || pod2usage();

$rcs++ if @rcsopt;
$diff = $rcs ? 'rcsdiff' : 'diff' unless $diff;

push(@diffopts,
     $opt_i ? "-i" : (),
     $opt_b ? "-b" : (),
     $opt_w ? "-w" : (),
     $opt_t ? "-t" : (),
     $opt_T ? "-T" : (),
    );

push(@sub_diffopts,
     $opt_i ? "-i" : (),
     $opt_w ? "-w" : (),
    );

my %colormap = (
    COMMAND => $opt_commandcolor ? "SE" : "",
    OMARK   => $opt_markcolor    ? "CS" : "",
    NMARK   => $opt_markcolor    ? "MS" : "",
    OTEXT   => $opt_textcolor    ? "C"  : "",
    NTEXT   => $opt_textcolor    ? "M"  : "",
    OCHANGE => "BDw",
    NCHANGE => "BDw",
    DELETE  => "RDw",
    APPEND  => "RDw",
    );

if (@opt_colormap) {
    map {
	my $c = pop @$_;
	map { $colormap{$_} = $c }
	map { match_glob $_, keys %colormap }
	@$_;
    }
    map { [ split /=/, $_, -1 ] }
    map { split /,/ }
    @opt_colormap;
}
print 'colormap = ', Dumper \%colormap if $opt_d;

my $opt_expand = $colormap{COMMAND} =~ /E/;
my $expand_width;
if ($opt_expand) {
    $expand_width = terminal_width();
}

my $DIFF;
my $OLD;
my $NEW;

if ($rcs) {
    my $rcsfile = shift || usage("No RCS filename\n\n");
    $DIFF = "$diff @diffopts @rcsopt $rcsfile|";
} elsif (@ARGV == 2) {
    ($OLD, $NEW) = splice(@ARGV, 0, 2);
    $DIFF = "$diff @diffopts $OLD $NEW |";
} elsif (@ARGV < 2) {
    $DIFF = shift || '-';
} else {
    usage("Arguments error.\n\n") if @ARGV;
}
print "DIFF = \"$DIFF\"\n" if $opt_d;

my %func = $opt_color ?
    (
     DELETE => sub { color("DELETE",  @_) },
     APPEND => sub { color("APPEND",  @_) },
     OLD    => sub { color("OCHANGE", @_) },
     NEW    => sub { color("NCHANGE", @_) },
    ) :
    (
     DELETE => \&bd,
     APPEND => \&bd,
     OLD    => \&ul,
     NEW    => \&ul,
    );

my $wchar_re = qr{
    [ \p{East_Asian_Width=Wide} \p{East_Asian_Width=FullWidth} ]
}x;

my $w_pattern;
if ($opt_B) {
    $w_pattern = qr/./s;
} else {
    $w_pattern = qr{
	\p{Han}+ | \p{InHiragana}+ | \p{InKatakana}+ |
	\p{Hang}+ |
	[a-zA-Z0-9_]+ | [ \t\r\f]*\n | \s+ | (.)\g{-1}*
    }x;
}
my @ul = ("", "_\010", "__\010\010");
my @bs = ("", "\010", "\010\010");

##
## Temporary file names
##
my $tmp = $opt_tmp || '/tmp';
my $TBASE = "$tmp/cdif_$$";
my($T1, $T2) = ("${TBASE}_1", "${TBASE}_2");

@SIG{'INT', 'HUP', 'QUIT', 'TERM'} = ('cleanup') x 4;

##
## Total statistic info
##
my %stat;
@stat{'a', 'd', 'c', 'anl', 'dnl', 'cnl'} = (0, 0, 0, 0, 0, 0);
@stat{'anlb', 'dnlb', 'cnlb'} = (0, 0, 0);

open(DIFF, $DIFF) || die "$DIFF: $!\n";
binmode DIFF, ":encoding(utf8)";

while (<DIFF>) {
    my($so, $se) = colorseq('S');
    my($left, $cmd, $right);
    #
    # normal diff
    #
    if (($left, $cmd, $right) = /^([\d,]+)([adc])([\d,]+)\r?$/) {
	print_command($_);
	my $old = read_diff(*DIFF, scalar(range($left)))  if $cmd =~ /[cd]/;
	my $del = read_diff(*DIFF, 1)                     if $cmd =~ /[c]/;
	my $new = read_diff(*DIFF, scalar(range($right))) if $cmd =~ /[ca]/;

	if ($cmd eq 'c') {
	    my($omark, $nmark) = ("< ", "> ");
	    $old =~ s/^(<[ \t])//mg and $omark = $1;
	    $new =~ s/^(>[ \t])//mg and $nmark = $1;

	    ($old, $new) = context($old, $new);

	    $old =~ s/^/$omark/mg;
	    $new =~ s/^/$nmark/mg;
	}

	if ($opt_color) {
	    $old =~ s{^(<[ \t])(.*)}{
		color("OMARK", $1) . color("OTEXT", $2)
	    }mge if $old;
	    $new =~ s{^(>[ \t])(.*)}{
		color("NMARK", $1) . color("NTEXT", $2)
	    }mge if $new;
	}

	print $old if $old;
	print $del if $del;
	print $new if $new;
    }
    #
    # diff -c
    #
    elsif (($left) = /^\*\*\* ([\d,]+) \*\*\*\*\r?$/) {
	print_command($_);
	my(@old, @new);
	@old = read_diffc(*DIFF, scalar(range($left)));
	my $new;
	if ($old[0] =~ /^--- /) {
	    $new = shift @old;
	    @old = ("");
	} else {
	    $new = <DIFF>;
	}
	if (($right) = $new =~ /^--- ([\d,]+) ----$/) {
	    if (@old == 1 and $old[0] ne "") {
		@new = ("");
	    } else {
		@new = read_diffc(*DIFF, scalar(range($right)));
	    }
	    for my $i (0 .. $#old) {
		my $cmark = "! ";
		if ($i % 2) {
		    $old[$i] =~ s/^(![ \t])//mg and $cmark = $1;
		    $new[$i] =~ s/^(![ \t])//mg and $cmark = $1;

		    ($old[$i], $new[$i]) = context($old[$i], $new[$i]);

		    $old[$i] =~ s/^/$cmark/mg;
		    $new[$i] =~ s/^/$cmark/mg;
		}
		if ($opt_color) {
		    $old[$i] =~ s{^([\-\!][ \t])(.*)}{
			color("OMARK", $1) . color("OTEXT", $2)
		    }mge;
		    $new[$i] =~ s{^([\+\!][ \t])(.*)}{
			color("NMARK", $1) . color("NTEXT", $2)
		    }mge;
		}
	    }
	}
	print @old, $new, @new;
    }
    #
    # diff -u
    #
    elsif (/^\@\@ -\d+(,(\d+))? \+\d+(,(\d+))? \@\@/)  {
	print_command($_);
	my @buf = read_diffu(*DIFF, $2 // 1, $4 // 1);
	while (my($same, $old, $new) = splice(@buf, 0, 3)) {
	    print $same;
	    my $tab = $opt_T ? "\t" : "";
	    if ($old and $new) {
		$old =~ s/^\-$tab//mgo;
		$new =~ s/^\+$tab//mgo;

		($old, $new) = context($old, $new);

		$old =~ s/^/-$tab/mg;
		$new =~ s/^/+$tab/mg;
	    }
	    if ($opt_color) {
		$old =~ s{^(\-)($tab.*)}{
		    color("OMARK", $1) . color("OTEXT", $2)
		}mge if $old;
		$new =~ s{^(\+)($tab.*)}{
		    color("NMARK", $1) . color("NTEXT", $2)
		}mge if $new;
	    }
	    print $old if $old;
	    print $new if $new;
	}
    }
    else {
	print;
    }
}
close DIFF;

if ($opt_stat) {
    select STDERR;

    print("TOTAL: ");
    printf("append=%d delete=%d change=%d\n",
	   $stat{'a'}, $stat{'d'}, $stat{'c'});
    print("INGORE WHITESPACE: ");
    printf("append=%d delete=%d change=%d\n",
	   $stat{'anl'},
	   $stat{'dnl'},
	   $stat{'cnl'});
    print("INGORE WHITESPACE (bytes): ");
    printf("append=%d delete=%d change=%d\n",
	   $stat{'anlb'},
	   $stat{'dnlb'},
	   $stat{'cnlb'});
}

exit $? >> 8;

######################################################################

sub print_command {
    my $line = shift;
    if ($opt_color) {
	if ($opt_expand and length($line) < $expand_width) {
	    $line =~ s/$/' ' x ($expand_width - length($_))/e;
	}
	$line = color($colormap{COMMAND}, $line);
    }
    print $line;
}

my $tmp_sequence = 0;

sub context {
    my($old, $new) = @_;
    local $_;

    if ($opt_keeptmpfile) {
	$tmp_sequence++;
	$T1 = sprintf("%s_%04d_1", $TBASE, $tmp_sequence);
	$T2 = sprintf("%s_%04d_2", $TBASE, $tmp_sequence);
    }

    if ($opt_d >= 2) {
	print STDERR "****************************** Comparing ...\n";
	print STDERR $old;
	print STDERR "****************************** and\n";
	print STDERR $new;
	print STDERR "****************************** .\n";
    }

    my %c = (a => 0, d => 0, c => 0);
    my @owlist = &maketmp($T1, $old);
    my @nwlist = &maketmp($T2, $new);
    my @command = ();

    open(CDIF, "diff @sub_diffopts $T1 $T2 |") || die "diff: $!\n";
    binmode CDIF, ":encoding(utf8)";
    while (<CDIF>) {
	print if $opt_d >= 2;
	if (/^[\d,]+([adc])[\d,]+$/) {
	    push @command, $_;
	    $c{$1}++;
	}
    }
    close CDIF;
    cleanup() unless $opt_keeptmpfile;

    if ($opt_d >= 1) {
	printf "old=%d new=%d command=%d\n", @owlist+0, @nwlist+0, @command+0;
	printf "append=$c{a} delete=$c{d} change=$c{c}\n";
    }

    my($obuf, $nbuf) = makebuf(\@owlist, \@nwlist, \@command);
    die "illegal status of subprocess\n" if ($?>>8) > 1;

    ($obuf, $nbuf);
}

sub cleanup {
    unlink $T1;
    unlink $T2;
    if (@_) {
	warn "\nSignal @_\n";
	exit 2;
    }
}

##
## Divide given text into word list.  Then write them into temporary
## file `$file' which include the word list one on each line.  The list
## itself is returned as a result of subroutine.
##
sub maketmp {
    my $tmp_file = shift;
    my $text = shift;
    my @words;
    my @notspace = (0);

    open(TMP, ">$tmp_file") || warn "$tmp_file: $!\n", return 0;
    binmode TMP, ":encoding(utf8)";

    while ($text =~ /($w_pattern)/g) {
	local $_ = $1;
	if ($opt_w) {
	    push(@notspace, !/\s/);
	    if (shift(@notspace) && $notspace[0]) {
		push(@words, '');
		print TMP "\n";
	    }
	}
	if (s/^(\s*)\n/\n/ && (length($1) || $opt_b || $opt_w)) {
	    #     ^ This have to be *.  Don't change to +.
	    print TMP ($opt_b || $opt_w) ? "\n" : "$1\n";
	    push(@words, $1);
	}
	push @words, $_;
	print TMP $_;
	print TMP "\n" unless /\n$/;
    }
    close TMP;

    if ($opt_d && @words != &wc_l($tmp_file)) {
	die "Error! (\@words != `wc -l $tmp_file`)\n";
    }

    @words;
}

##
##  @owlist: old word list
##  @nwlist: new word list
##  @command: how different these lists (`diff' result command lines)
##
sub makebuf {
    my($ol, $nl, $ctrl) = @_;
    my @owlist = @$ol;
    my @nwlist = @$nl;
    my @command = @$ctrl;

    my($o, $n) = (0, 0);	# pointers
    my(@obuf, @nbuf);

    for (@command) {
	my($old, $ctrl, $new) = /([\d,]+)([adc])([\d,]+)/ or do {
	    die "Panic! Unexpected diff output";
	};
	my($o1, $o2) = range($old);
	my($n1, $n2) = range($new);
	map { $_-- } $o1, $o2, $n1, $n2; # make them zero origined

	push(@obuf, @owlist[$o .. $o1 - 1]), $o = $o1 if $o < $o1;
	push(@nbuf, @nwlist[$n .. $n1 - 1]), $n = $n1 if $n < $n1;

	$stat{$ctrl}++;

	if ($ctrl eq 'd') {
	    my $os = join('', @owlist[$o1 .. $o2]);
	    if ($owlist[$o2] =~ /\S/) {
		$stat{'dnl'}++;
		$stat{'dnlb'} += length($os);
	    }
	    push(@obuf, $func{DELETE}->($os));
	    $o = $o2 + 1;
	}
	elsif ($ctrl eq 'c') {
	    my $os = join('', @owlist[$o1 .. $o2]);
	    my $ns = join('', @nwlist[$n1 .. $n2]);
	    if (($owlist[$o2] =~ /\S/) || ($nwlist[$n2] =~ /\S/)) {
		$stat{'cnl'}++;
		$stat{'cnlb'} += length($os);
		$stat{'cnlb'} += length($ns);
	    }
	    push(@obuf, $func{OLD}->($os));
	    push(@nbuf, $func{NEW}->($ns));
	    $o = $o2 + 1;
	    $n = $n2 + 1;
	}
	elsif ($ctrl eq 'a') {
	    my $ns = join('', @nwlist[$n1 .. $n2]);
	    if ($nwlist[$n2] =~ /\S/) {
		$stat{'anl'}++;
		$stat{'anlb'} += length($ns);
	    }
	    push(@nbuf, $func{APPEND}->($ns));
	    $n = $n2 + 1;
	}
    }
    push(@obuf, @owlist[$o .. $#owlist]);
    push(@nbuf, @nwlist[$n .. $#nwlist]);

    (join('', @obuf), join('', @nbuf));
}

sub read_diff {
    my($FH, $c) = @_;
    my @buf = ();
    while ($c-- > 0) {
	push @buf, scalar <$FH>;
    }
    wantarray ? @buf : join '', @buf;
}

sub read_diffc {
    my($FH, $n) = @_;
    my @buf;
    local $_;
    my $i = 0;
    while ($n-- && ($_ = <$FH>)) {
	$i++ if ($i % 2) != /^!/;
	$buf[$i] .= $_;
	last if /^--- /;
    }
    map { $_ // "" } @buf;
}

sub read_diffu {
    my $FH = shift;
    my @l = (0, @_);

    my $i = 0;
    my @buf;
    my $slot;
    my %slot = (" " => 0, "\t" => 0, "-" => 1, "+" => 2);
    for (; 2 * $l[0] + $l[1] + $l[2] > 0 && ($_ = <$FH>); $buf[$i] .= $_) {
	$i++ while ($i % 3) != ($slot = $slot{substr($_, 0, 1)});
	$l[$slot]--;
    }
    map { $_ // "" } @buf;
}

## 
## Copied from MBprintf.pm
## 
sub mbwidth {
    my $arg = shift;
    my $len = length($arg);
    while ($arg =~ m/($wchar_re+)/go) {
	$len += length($1);
    }
    $len;
}

sub ul {
    local $_ = join '', @_;
    s/(.)/$ul[mbwidth($1)].$1/ge;
    $_;
}
sub bd {
    local $_ = join '', @_;
    s/(\S)/$1.$bs[mbwidth($1)].$1/ge;
    $_;
}

sub range {
    local $_ = shift;
    my($from, $to) = /,/ ? split(/,/) : ($_, $_);
    wantarray ? ($from, $to) : $to == 0 ? 0 : $to - $from + 1;
}

use Term::ANSIColor qw(:constants);

sub colorseq {
    my $colormode = shift;

    my($start, $end) = ('', '');
    if ($colormode =~ /,/) {
	($start, $end) = split(/,/, $colormode, 2);
    } else {
	map {
	    $start .= UNDERLINE if /U/;
	    $start .= REVERSE   if /S/;
	    $start .= BOLD      if /D/;
	    $start .= RED       if /R/; $start .= ON_RED       if /r/;
	    $start .= GREEN     if /G/; $start .= ON_GREEN     if /g/;
	    $start .= BLUE      if /B/; $start .= ON_BLUE      if /b/;
	    $start .= CYAN      if /C/; $start .= ON_CYAN      if /c/;
	    $start .= MAGENTA   if /M/; $start .= ON_MAGENTA   if /m/;
	    $start .= YELLOW    if /Y/; $start .= ON_YELLOW    if /y/;
	    $start .= WHITE     if /W/; $start .= ON_WHITE     if /w/;
	} $colormode if $colormode;
	$end = RESET if $start;
	$start =~ s/m\e\[/;/g;
    }
    ($start, $end);
}

my %colorcache;
my $reset_re;
BEGIN {
    my $reset = RESET;
    $reset_re = qr/\Q$reset/;
}

sub color {
    my($color, $text) = @_;
    return $text unless $color;
    unless ($colorcache{$color}) {
	my $mode = exists $colormap{$color} ? $colormap{$color} : $color;
	$colorcache{$color} = [ colorseq($mode) ];
    }
    my($s, $e) = @{$colorcache{$color}};
    if ($s ne "") {
	$text =~ s/(^|$reset_re)([^\e\r\n]+)/$1$s$2$e/mg;
    }
    $text;
}

sub wc_l {
    my $file = shift;
    my $line;
    local *FILE;
    open(FILE, $file) || die "$file: $!\n";
    $line++ while <FILE>;
    close FILE;
    $line;
}

sub eval {
    print STDERR &unctrl($_[0]), "\n" x ($_[0] !~ /\n$/) if $_[1] || $opt_d;
    eval shift;
    die sprintf("eval failed in file %s on line %s\n$@", (caller)[1,2]) if $@;
}

sub unctrl {
    local $_ = shift;
    s/([\000-\010\013-\037])/'^' . pack('c', ord($1)|0100)/ge;
    $_;
}

sub terminal_width {
    my $width = 80;
    if (-t STDERR) {
	my $stty = `stty -f /dev/stderr all`; # XXX too easy...
	if ($stty =~ /(\d+) +columns/) {
	    $width = $1;
	}
    }
    $width;
}

######################################################################

=head1 NAME

cdif - word context diff

=head1 SYNOPSIS

cdif [cdif option] file1 file2

cdif [rcs options] [cdif options] file

cdif [cdif options] [diff-data]

Options:

	-c, -Cn		context diff
	-u, -Un		unified diff
	-i		ignore case
	-b		ignore trailing blank
	-w		ignore whitespace
	-t		expand tabs
	-T		initial tabs
	--rcs		use rcsdiff
	-r<rev>, -q	rcs options

	-B                  char-by-char comparison
	--diff=command      specify diff command
	--stat              show statistical information
	--colormap=s        specify color map
	--[no]color         color or not           (default true)
	--[no]commandcolor  color for command line (default true)
	--[no]markcolor     color for diff mark    (default true)
	--[no]textcolor     color for normal text  (default true)


=head1 DESCRIPTION

B<cdif> is a post-processor of the Unix diff command.  It highlights
deleted, changed and added words based on word context.

You may want to compare character-by-character rather than
word-by-word.  Option B<-B> option can be used for that purpose.

If only one file is specified, cdif reads that file (stdin if no file)
as a output from diff command.

Lines those don’t look like diff output are simply ignored and
printed.

=head1 OPTIONS

=over 7

=item B<->[B<cCuUibwtT>]

Almost same as B<diff> command.

=item B<--rcs>, B<-r>I<rev>, B<-q>

Use rcsdiff instead of normal diff.  Option B<--rcs> is not required
when B<-r>I<rev> is supplied.

=item B<-B>, B<--char>

Compare the data character-by-character context.

=item B<--diff>=I<command>

Specify the diff command to use.

=item B<-->[B<no>]B<color>

Use ANSI color escape sequence for output.

=item B<--colormap>=I<colormap>, B<--cm>=I<colormap>

Basic I<colormap> format is :

    FIELD=COLOR

where the FIELD is one from these :

    COMMAND  Command line
    OMARK    Old mark
    NMARK    New mark
    OTEXT    Old text
    NTEXT    New text
    OCHANGE  Old change part
    NCHANGE  New change part
    APPEND   Appended part
    DELETE   Deleted part

You can make multiple filelds same color joining them by = :

    FIELD1=FIELD2=...=COLOR

Also wildcard can be used for field name :

    *CHANGE=BDw

Multiple fields can be specified by repeating options

    --cm FILED1=COLOR1 --cm FIELD2=COLOR2 ...

or combined with comma (,) :

    --cm FILED1=COLOR1,FIELD2=COLOR2, ...

COLOR is combination of single character representing uppercase
foreground color :

    R  Red
    G  Green
    B  Blue
    C  Cyan
    M  Magenta
    Y  Yellow
    W  White

and corresponding lowercase background color :

    r, g, b, c, m, y, w

and other effects :

    S  Standout (reverse video)
    U  Underline
    D  Double-struck (boldface)
    E  Expand (only for command line)

When B<E> is specified for command line, the line is expanded to
window width filling up by space characters.

Defaults are :

    COMMAND => "SE"
    OMARK   => "CS"
    NMARK   => "MS"
    OTEXT   => "C"
    NTEXT   => "M"
    OCHANGE => "BDw"
    NCHANGE => "BDw"
    DELETE  => "RDw"
    APPEND  => "RDw"

This is equivalent to :

    cdif --cm 'COMMAND=SE,OMARK=CS,NMARK=MS' \
         --cm 'OTEXT=C,NTEXT=M,*CHANGE=BDw,DELETE=APPEND=RDw'

=item B<-->[B<no>]B<commandcolor>, B<--cc>

=item B<-->[B<no>]B<markcolor>, B<--mc>

=item B<-->[B<no>]B<textcolor>, B<--tc>

Enable/Disable using color for the corresponding field.

=item B<--stat>

Print statistical information at the end of output.  It shows number
of total appended/deleted/changed words in the context of cdif.  It's
common to have many insertions and deletions of newlines becuase of
text filling process.  So normal informaiton is followed by modified
number which ignores insert/delete newlines.

=back

=head1 AUTHOR

Kazumasa Utashiro

https://github.com/kaz-utashiro/cdif

=head1 SEE ALSO

perl(1), diff(1)

=head1 BUGS

B<cdif> is naturally not very fast because it uses normal diff command
as a backend processor to compare words.

=head1 COPYRIGHT

Use and redistribution for ANY PURPOSE are granted as long as all
copyright notices are retained.  Redistribution with modification is
allowed provided that you make your modified version obviously
distinguishable from the original one.  THIS SOFTWARE IS PROVIDED BY
THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE
DISCLAIMED.
